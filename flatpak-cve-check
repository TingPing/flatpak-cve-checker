#!/usr/bin/env python3
# SPDX-License: GPL-3.0-or-later
# Copyright 2018 Igalia S.L.

import argparse
import csv
import json
import os
import re
import subprocess
import sys
import tempfile
from collections import namedtuple
from contextlib import suppress

import gi
try:
    import gitlab
except ImportError:
    gitlab = None

gi.require_versions({
    'Flatpak': '1.0',
})

from gi.repository import Flatpak, GLib


def get_directory_for_ref(name, branch):
    ref = None
    for install in [Flatpak.Installation.new_user()] + Flatpak.get_system_installations():
        for kind in (Flatpak.RefKind.APP, Flatpak.RefKind.RUNTIME):
            if ref:
                break
            with suppress(GLib.Error):
                ref = install.get_installed_ref(kind, name, None, branch, None)
    if not ref:
        sys.exit('Failed to find ref {}//{}'.format(name, branch))

    return os.path.join(ref.get_deploy_dir(), 'files')


def guess_version(sources):
    for source in sources:
        if source['type'] == 'archive':
            filename = source['url'].rpartition('/')[2]
            match = re.search(r'(\d+\.\d+(?:\.\d+)?)', filename)
            if match:
                return match.groups()[-1]
            else:
                print('Version not found in {}'.format(sources))


Module = namedtuple('Module', ['name', 'version', 'patches', 'ignored'])


def extract_info_from_base(data):
    # This parses manifest.base files generated by the yocto layer
    # it can't contain a lot of useful information we need so we
    # will have to manually override info here if we care but
    # 18.08 is here with better tooling so we might not.
    modules = []
    for line in data.split('\n'):
        if line:
            name, _, version = line.split(' ', 3)
            modules.append(Module(name, version, '', ''))
    return modules


def extract_info_from_json(data):
    content = json.loads(data)
    modules = []
    for module in content['modules']:
        name = version = patches = ignored = ''
        if 'x-cpe' in module:
            # TODO: Handle lists here in case multiple products
            #       are in one module
            version = module['x-cpe'].get('version')
            name = module['x-cpe'].get('product')
            patches = module['x-cpe'].get('patches', []).join(' ')
            ignored = module['x-cpe'].get('ignored', []).join(' ')
        if not version:
            version = guess_version(module['sources'])
        if not name:
            name = module['name']
        if version:
            modules.append(Module(name, version, patches, ignored))
    return modules


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('id')
    parser.add_argument('branch')
    parser.add_argument('--report', action='store_true')
    args = parser.parse_args()

    directory = get_directory_for_ref(args.id, args.branch)
    manifests = [d.path for d in os.scandir(directory) if d.name.startswith('manifest')]
    modules = []
    for manifest in manifests:
        data = open(manifest).read()
        if manifest.endswith('.json'):
            modules += extract_info_from_json(data)
        else:
            modules += extract_info_from_base(data)

    temp = tempfile.NamedTemporaryFile(mode='w', delete=False)
    writer = csv.writer(temp)
    for module in modules:
        writer.writerow([module.name, module.version, module.patches, module.ignored])
    temp.close()

    cve_command = ['cve-check-tool', '--skip-update', '--type=faux', temp.name]
    if args.report:
        cve_command.append('--csv')
    else:
        cve_command.append('--no-html')
    cve_output = subprocess.check_output(cve_command).decode().rstrip()
    if not cve_output:
        print('No CVEs found!')
        sys.exit(0)

    if not args.report:
        print(cve_output)
        sys.exit(0)

    markdown_output = ''
    reader = csv.reader(cve_output.split('\n'))
    for module in reader:
        # TODO: Adding a readable description requires modifications to the cve-check-tool
        urls = ['[{0}](https://web.nvd.nist.gov/view/vuln/detail?vulnId={0})'.format(cve) for cve in module[2].split(' ')]
        markdown_output += '\n- {} ({})\n  - [ ]{}'.format(module[0], module[1], '\n  - [ ] '.join(urls))

    if not gitlab:
        sys.exit('python-gitlab is not installed to report this issue automatically')

    # TODO: Expose configuration of this
    try:
        gl = gitlab.Gitlab.from_config('gitlab.com', ['gitlab.cfg'])
        project = gl.projects.get('TingPing/freedesktop-sdk')
        issue = project.issues.create({
            'title': 'New CVEs detected!',
            'description': markdown_output.strip(),
            'confidential': True,
            'labels': 'High Priority',
        })
    except Exception as e:
        print(markdown_output)
        sys.exit('Failed to automatically log in and report: {}'.format(e))
