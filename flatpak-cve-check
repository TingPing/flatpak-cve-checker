#!/usr/bin/env python3
# SPDX-License: GPL-3.0-or-later
# Copyright 2018 Igalia S.L.

import argparse
import configparser
import csv
import configparser
import json
import os
import re
import subprocess
import sys
import tempfile
from collections import namedtuple
from contextlib import suppress
from typing import List
from urllib.parse import quote

import gi
try:
    import gitlab
except ImportError:
    gitlab = None

gi.require_versions({
    'Flatpak': '1.0',
})

from gi.repository import Flatpak, GLib, Gio


def get_directory_for_ref(flatpak_id):
    if not '/' in flatpak_id:
        name = flatpak_id
        branch = 'stable'
    else:
        try:
            name, _, branch = flatpak_id.split('/', 3)
        except ValueError:
            sys.exit('id must be in the format: org.example.App//branch')

    ref = None
    for install in [Flatpak.Installation.new_user()] + Flatpak.get_system_installations():
        for kind in (Flatpak.RefKind.APP, Flatpak.RefKind.RUNTIME):
            if ref:
                break
            with suppress(GLib.Error):
                ref = install.get_installed_ref(kind, name, None, branch, None)
    if not ref:
        sys.exit('Failed to find id {}//{}'.format(name, branch))

    return os.path.join(ref.get_deploy_dir(), 'files')


def update_ref(flatpak_id, remote):
    subprocess.run(['flatpak', 'remote-add', '--user', '--if-not-exists', remote['name'], remote['url']], check=True)
    subprocess.run(['flatpak', 'install', '--user', '-y', '--no-related', remote['name'], flatpak_id], check=True)
    subprocess.run(['flatpak', 'update', '--user', '-y', '--no-related', flatpak_id], check=True)


def guess_version(sources):
    for source in sources:
        if source['type'] == 'archive':
            filename = source['url'].rpartition('/')[2]
            match = re.search(r'(\d+\.\d+(?:\.\d+)?)', filename)
            if match:
                return match.groups()[-1]
            else:
                print('Version not found in {}'.format(sources))


def guess_patches(sources):
    patch_files = []
    for source in sources:
        if source['type'] == 'patch':
            if 'path' in source:
                patch_files.append(source['path'])
            patch_files += source.get('paths', [])

    patched_cves = []
    for patch in patch_files:
        match = re.search(r'(CVE-\d{4}-\d+)', patch)
        if match:
            patched_cves.append(match.groups()[0])
    return ' '.join(patched_cves)


Module = namedtuple('Module', ['name', 'version', 'cves', 'patches', 'ignored'])


def extract_info_from_base(data):
    # This parses manifest.base files generated by the yocto layer
    # it can't contain a lot of useful information we need so we
    # will have to manually override info here if we care but
    # 18.08 is here with better tooling so we might not.

    # cve-check-tool has mapping built in but it seems broken
    # in a few ways so we can just map these here.
    # I kept the same format just in case its fixed there
    config = configparser.ConfigParser()
    config.read('yocto-mappings.ini')
    patches = config['Patches']
    ignored = config['Ignored']
    mappings = config['Mapping']
    module_map = {v: k.split(',')[0] for k, v in mappings.items()}

    modules = []
    for line in data.split('\n'):
        if line:
            name, _, version = line.split(' ', 3)
            name = quote(module_map.get(name, name))
            patch = patches.get(name, '')
            ignore = ignored.get(name, '')
            modules.append(Module(name, version, '', patch, ignore))
    return modules


def extract_info_from_json(data):
    content = json.loads(data)
    modules = []
    for module in content['modules']:
        name = version = patches = ignored = ''
        if 'x-cpe' in module:
            # TODO: Handle lists here in case multiple products
            #       are in one module
            version = module['x-cpe'].get('version')
            name = module['x-cpe'].get('product')
            patches = ' '.join(module['x-cpe'].get('patches', []))
            ignored = ' '.join(module['x-cpe'].get('ignored', []))
        if not patches:
            patches = guess_patches(module['sources'])
        if not version:
            version = guess_version(module['sources'])
        if not name:
            name = module['name']

        if version:
            modules.append(Module(quote(name), version, '', patches, ignored))
    return modules


def get_output_for_id(flatpak_id, flatpak_remote, csv_format, update):
    if update:
        update_ref(flatpak_id, flatpak_remote)

    directory = get_directory_for_ref(flatpak_id)
    manifests = [d.path for d in os.scandir(directory) if d.name.startswith('manifest')]
    modules = []
    for manifest in manifests:
        data = open(manifest).read()
        if manifest.endswith('.json'):
            modules += extract_info_from_json(data)
        else:
            modules += extract_info_from_base(data)

    if not modules:
        print('No modules found in manifest')
        sys.exit(1)

    temp = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False)
    writer = csv.writer(temp)
    for module in modules:
        writer.writerow([quote(module.name), module.version, module.patches, module.ignored])
    temp.close()

    cve_command = ['cve-check-tool', '--type=faux', '--skip-update', temp.name]
    if csv_format:
        cve_command.append('--csv')
    else:
        cve_command.append('--no-html')  # FIXME: This output by cve-check-tool seems broken

    return subprocess.check_output(cve_command).decode().rstrip()


def get_modules_from_csv(data, reported):
    reader = csv.reader(data.split('\n'))
    modules = []
    for module in reader:
        cves = ' '.join(cve for cve in module[2].split(' ') if cve not in reported)
        if cves:
            modules.append(Module(module[0], module[1], cves, '', ''))
    return modules


def get_markdown_for_modules(modules: List[Module]):
    markdown_output = ''
    for module in modules:
        # TODO: Adding a readable description requires modifications to the cve-check-tool
        urls = ['[{0}](https://web.nvd.nist.gov/view/vuln/detail?vulnId={0})'.format(cve) for cve in module.cves.split(' ')]
        markdown_output += '\n- {} ({})\n  - [ ] {}'.format(module.name, module.version, '\n  - [ ] '.join(urls))
    return markdown_output.rstrip()


def report_to_gitlab(config, title, description):
    if gitlab is None:
        print('gitlab module is not installed!')
        return False

    token = config.get('token')
    if not token:
        print('gitlab token required!')
        return False

    gl = gitlab.Gitlab(config['url'], private_token=token)
    project = gl.projects.get(config['repo'])
    issue = project.issues.create({
        'title': 'Testing!',
        'description': 'idk' + description,
        'confidential': config.get('confidential', True),
        'labels': config.get('labels', []),
    })
    print('Reported: ', issue.web_url)
    return True


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--id', action='store')
    parser.add_argument('--config', action='store')
    parser.add_argument('--no-report', action='store_true')
    args = parser.parse_args()

    if not args.id and not args.config:
        sys.exit('Please specify --id or --config')

    if args.config:
        try:
            report_file = open('report-history.json', 'r+')
            report_history = json.load(report_file)
        except FileNotFoundError:
            report_file = open('report-history.json', 'w+')
            report_history = {}
        config = json.load(open(args.config))

        if config.get('auto-update-cves', False):
            subprocess.run(['cve-check-update'], check=True)

        update_flatpaks = config.get('auto-update-flatpaks', False)

        for package in config['packages']:
            flatpak_id = package['flatpak-name']
            remote = config['repos'][package['flatpak-repo']]
            remote['name'] = package['flatpak-repo']
            ret = get_output_for_id(flatpak_id, remote, True, update_flatpaks)

            if not ret:
                print('No CVEs found for {}'.format(flatpak_id))
                continue

            reported = report_history.get(flatpak_id, [])
            print(reported)
            modules = get_modules_from_csv(ret, reported)

            if not modules:
                print('No new CVEs found for {}'.format(flatpak_id))
                continue

            markdown = get_markdown_for_modules(modules)
            if args.no_report:
                print(markdown)
                sys.exit(0)

            service = config['services'][package['service']]
            if service['type'] == 'gitlab':
                service['repo'] = package['service-repo']
                if report_to_gitlab(service, 'New CVE(s) found!', markdown):
                    for module in modules:
                        reported += module.cves.split(' ')
                    report_history[flatpak_id] = reported
                    json.dump(report_history, report_file, indent=2)
            else:
                print('Service {} not supported'.format(package['service']))
    else:
        ret = get_output_for_id(args.id, None, False, False)
        if not ret:
            print('No CVEs found!')
        else:
            print(ret)
