#!/usr/bin/env python3
# SPDX-License: GPL-3.0-or-later
# Copyright 2018 Igalia S.L.

import argparse
import configparser
import csv
import json
import os
import re
import subprocess
import sys
import tempfile
from collections import namedtuple
from contextlib import suppress
from urllib.parse import quote

import gi
try:
    import gitlab
except ImportError:
    gitlab = None

gi.require_versions({
    'Flatpak': '1.0',
})

from gi.repository import Flatpak, GLib, Gio


def get_directory_for_ref(name, branch):
    ref = None
    for install in [Flatpak.Installation.new_user()] + Flatpak.get_system_installations():
        for kind in (Flatpak.RefKind.APP, Flatpak.RefKind.RUNTIME):
            if ref:
                break
            with suppress(GLib.Error):
                ref = install.get_installed_ref(kind, name, None, branch, None)
    if not ref:
        sys.exit('Failed to find ref {}//{}'.format(name, branch))

    return os.path.join(ref.get_deploy_dir(), 'files')


def guess_version(sources):
    for source in sources:
        if source['type'] == 'archive':
            filename = source['url'].rpartition('/')[2]
            match = re.search(r'(\d+\.\d+(?:\.\d+)?)', filename)
            if match:
                return match.groups()[-1]
            else:
                print('Version not found in {}'.format(sources))


def guess_patches(sources):
    patch_files = []
    for source in sources:
        if source['type'] == 'patch':
            if 'path' in source:
                patch_files.append(source['path'])
            patch_files += source.get('paths', [])

    patched_cves = []
    for patch in patch_files:
        match = re.search(r'(CVE-\d{4}-\d+)', patch)
        if match:
            patched_cves.append(match.groups()[0])
    return ' '.join(patched_cves)


Module = namedtuple('Module', ['name', 'version', 'patches', 'ignored'])


def extract_info_from_base(data):
    # This parses manifest.base files generated by the yocto layer
    # it can't contain a lot of useful information we need so we
    # will have to manually override info here if we care but
    # 18.08 is here with better tooling so we might not.

    # cve-check-tool has mapping built in but it seems broken
    # in a few ways so we can just map these here.
    # I kept the same format just in case its fixed there
    config = configparser.ConfigParser()
    config.read('yocto-mappings.ini')
    patches = config['Patches']
    ignored = config['Ignored']
    mappings = config['Mapping']
    module_map = {v: k.split(',')[0] for k, v in mappings.items()}

    modules = []
    for line in data.split('\n'):
        if line:
            name, _, version = line.split(' ', 3)
            name = module_map.get(name, name)
            patch = patches.get(name, '')
            ignore = ignored.get(name, '')
            modules.append(Module(name, version, patch, ignore))
    return modules


def extract_info_from_json(data):
    content = json.loads(data)
    modules = []
    for module in content['modules']:
        name = version = patches = ignored = ''
        if 'x-cpe' in module:
            # TODO: Handle lists here in case multiple products
            #       are in one module
            version = module['x-cpe'].get('version')
            name = module['x-cpe'].get('product')
            patches = ' '.join(module['x-cpe'].get('patches', []))
            ignored = ' '.join(module['x-cpe'].get('ignored', []))
        if not patches:
            patches = guess_patches(module['sources'])
        if not version:
            version = guess_version(module['sources'])
        if not name:
            name = module['name']
        if version:
            modules.append(Module(name, version, patches, ignored))
    return modules


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('id')
    parser.add_argument('branch')
    parser.add_argument('--report', action='store_true')
    args = parser.parse_args()

    directory = get_directory_for_ref(args.id, args.branch)
    manifests = [d.path for d in os.scandir(directory) if d.name.startswith('manifest')]
    modules = []
    for manifest in manifests:
        data = open(manifest).read()
        if manifest.endswith('.json'):
            modules += extract_info_from_json(data)
        else:
            modules += extract_info_from_base(data)

    if not modules:
        print('No modules found in manifest')
        sys.exit(1)

    temp = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False)
    writer = csv.writer(temp)
    for module in modules:
        writer.writerow([quote(module.name), module.version, module.patches, module.ignored])
    temp.close()

    temp_out = tempfile.NamedTemporaryFile(mode='w', prefix='{}-{}-'.format(args.id, args.branch),
                                           suffix='.html', delete=False).name
    cve_command = ['cve-check-tool', '--skip-update', temp.name]
    if args.report:
        cve_command.append('--csv')
    else:
        cve_command += ['--output-file', temp_out]
    cve_output = subprocess.check_output(cve_command).decode().rstrip()

    if not args.report:
        Gio.AppInfo.launch_default_for_uri('file://' + temp_out)
        sys.exit(0)

    if not cve_output:
        print('No CVEs found!')
        sys.exit(0)

    markdown_output = ''
    reader = csv.reader(cve_output.split('\n'))
    for module in reader:
        # TODO: Adding a readable description requires modifications to the cve-check-tool
        urls = ['[{0}](https://web.nvd.nist.gov/view/vuln/detail?vulnId={0})'.format(cve) for cve in module[2].split(' ')]
        markdown_output += '\n- {} ({})\n  - [ ]{}'.format(module[0], module[1], '\n  - [ ] '.join(urls))

    if not gitlab:
        sys.exit('python-gitlab is not installed to report this issue automatically')

    # TODO: Expose configuration of this
    try:
        gl = gitlab.Gitlab.from_config('gitlab.com', ['gitlab.cfg'])
        project = gl.projects.get('TingPing/freedesktop-sdk')
        issue = project.issues.create({
            'title': 'New CVEs detected!',
            'description': markdown_output.strip(),
            'confidential': True,
            'labels': 'High Priority',
        })
    except Exception as e:
        print(markdown_output)
        sys.exit('Failed to automatically log in and report: {}'.format(e))
