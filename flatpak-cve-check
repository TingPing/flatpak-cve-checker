#!/usr/bin/env python3
# SPDX-License: GPL-3.0-or-later
# Copyright 2018 Igalia S.L.

import argparse
import concurrent.futures
import configparser
import csv
import json
import os
import re
import subprocess
import sys
import tempfile
import urllib.error
import urllib.request
from collections import namedtuple
from contextlib import suppress
from typing import List
from urllib.parse import quote

import gi
try:
    import gitlab
except ImportError:
    gitlab = None

gi.require_versions({
    'Flatpak': '1.0',
    'AppStreamGlib': '1.0',
})

from gi.repository import Flatpak, AppStreamGlib, GLib, Gio


def get_directory_for_ref(flatpak_id):
    if not '/' in flatpak_id:
        name = flatpak_id
        branch = 'stable'
    else:
        try:
            name, _, branch = flatpak_id.split('/', 3)
        except ValueError:
            sys.exit('id must be in the format: org.example.App//branch')

    ref = None
    for install in [Flatpak.Installation.new_user()] + Flatpak.get_system_installations():
        for kind in (Flatpak.RefKind.APP, Flatpak.RefKind.RUNTIME):
            if ref:
                break
            with suppress(GLib.Error):
                ref = install.get_installed_ref(kind, name, None, branch, None)
    if not ref:
        sys.exit('Failed to find id {}//{}'.format(name, branch))

    return os.path.join(ref.get_deploy_dir(), 'files')


def update_ref(flatpak_id, remote):
    subprocess.run(['flatpak', 'remote-add', '--user', '--if-not-exists', remote['name'], remote['url']], check=True)
    subprocess.run(['flatpak', 'install', '--user', '-y', '--no-related', remote['name'], flatpak_id], check=True)
    subprocess.run(['flatpak', 'update', '--user', '-y', '--no-related', flatpak_id], check=True)


def guess_version(sources):
    for source in sources:
        if source['type'] == 'archive':
            filename = source['url'].rpartition('/')[2]
            match = re.search(r'(\d+\.\d+(?:\.\d+)?)', filename)
            if match:
                return match.groups()[-1]
            else:
                print('Version not found in {}'.format(sources))


def guess_patches(sources):
    patch_files = []
    for source in sources:
        if source['type'] == 'patch':
            if 'path' in source:
                patch_files.append(source['path'])
            patch_files += source.get('paths', [])

    patched_cves = []
    for patch in patch_files:
        match = re.search(r'(CVE-\d{4}-\d+)', patch)
        if match:
            patched_cves.append(match.groups()[0])
    return ' '.join(patched_cves)


Module = namedtuple('Module', ['name', 'version', 'cves', 'patches', 'ignored'])


def extract_info_from_base(data):
    # This parses manifest.base files generated by the yocto layer
    # it can't contain a lot of useful information we need so we
    # will have to manually override info here if we care but
    # 18.08 is here with better tooling so we might not.

    # cve-check-tool has mapping built in but it seems broken
    # in a few ways so we can just map these here.
    # I kept the same format just in case its fixed there
    config = configparser.ConfigParser()
    config.read('yocto-mappings.ini')
    patches = config['Patches']
    ignored = config['Ignored']
    mappings = config['Mapping']
    module_map = {v: k.split(',')[0] for k, v in mappings.items()}

    modules = []
    for line in data.split('\n'):
        if line:
            name, _, version = line.split(' ', 3)
            name = quote(module_map.get(name, name))
            patch = patches.get(name, '')
            ignore = ignored.get(name, '')
            modules.append(Module(name, version, '', patch, ignore))
    return modules


def extract_info_from_json(data):
    content = json.loads(data)
    modules = []
    for module in content['modules']:
        name = version = patches = ignored = ''
        if 'x-cpe' in module:
            # TODO: Handle lists here in case multiple products
            #       are in one module
            version = module['x-cpe'].get('version')
            name = module['x-cpe'].get('product')
            patches = ' '.join(module['x-cpe'].get('patches', []))
            ignored = ' '.join(module['x-cpe'].get('ignored', []))
        if not patches:
            patches = guess_patches(module['sources'])
        if not version:
            version = guess_version(module['sources'])
        if not name:
            name = module['name']

        if version:
            modules.append(Module(quote(name), version, '', patches, ignored))
    return modules


def get_modules_for_id(flatpak_id, flatpak_remote, update):
    if update:
        update_ref(flatpak_id, flatpak_remote)

    directory = get_directory_for_ref(flatpak_id)
    manifests = [d.path for d in os.scandir(directory) if d.name.startswith('manifest')]
    modules = []
    for manifest in manifests:
        data = open(manifest).read()
        if manifest.endswith('.json'):
            modules += extract_info_from_json(data)
        else:
            modules += extract_info_from_base(data)
    return modules


def get_output_for_modules(modules, csv_format):
    temp = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False)
    writer = csv.writer(temp)
    for module in modules:
        writer.writerow([quote(module.name), module.version, module.patches, module.ignored])
    temp.close()

    cve_command = ['cve-check-tool', '--type=faux', '--skip-update', temp.name]
    if csv_format:
        cve_command.append('--csv')
    else:
        cve_command.append('--no-html')  # FIXME: This output by cve-check-tool seems broken

    return subprocess.check_output(cve_command).decode().rstrip()


def get_modules_from_csv(data, reported):
    reader = csv.reader(data.split('\n'))
    modules = []
    for module in reader:
        cves = ' '.join(cve for cve in module[2].split(' ') if cve not in reported)
        if cves:
            modules.append(Module(module[0], module[1], cves, '', ''))
    return modules


ModuleUpdateInfo = namedtuple('ModuleUpdateInfo', ['name', 'local_version', 'upstream_version'])


def get_updates_markdown_for_modules(modules: List[ModuleUpdateInfo]) -> str:
    markdown_output = ''
    for module in modules:
        markdown_output += '- [ ] {} *({} â†’ {})*\n'.format(module.name, module.local_version, module.upstream_version)
    return markdown_output.rstrip()


def get_cve_markdown_for_modules(modules: List[Module]) -> str:
    markdown_output = ''
    for module in modules:
        # TODO: Adding a readable description requires modifications to the cve-check-tool
        urls = ['[{0}](https://web.nvd.nist.gov/view/vuln/detail?vulnId={0})'.format(cve) for cve in module.cves.split(' ')]
        markdown_output += '\n- {} ({})\n  - [ ] {}'.format(module.name, module.version, '\n  - [ ] '.join(urls))
    return markdown_output.rstrip()


def get_sanitized_upstream_version(response):
    # We don't want the latest development versions so only return last even release
    if response['backend'] == 'GNOME':
        for version in response['versions']:
            if int(version.split('.')[1]) % 2 == 0:
                return version
    return response['versions'][0]


def get_module_updates(modules: List[Module], distro_name, reported):
    updates = []

    def request_module_update(module):
        try:
            ret = urllib.request.urlopen('https://release-monitoring.org/api/project/{}/{}'.format(quote(distro_name),
                                                                                                   quote(module.name)))
        except urllib.error.HTTPError as e:
            print('Failed to get updates for {}: {}'.format(module.name, e))
            return None
        else:
            return ret.read()

    with concurrent.futures.ThreadPoolExecutor(max_workers=64) as executor:
        future_to_module = {executor.submit(request_module_update, module): module
                            for module in modules[0:64] if module.name not in reported}
        for future in concurrent.futures.as_completed(future_to_module):
            module = future_to_module[future]
            data = future.result()
            if not data:
                continue
            response = json.loads(data)
            current_version = get_sanitized_upstream_version(response)
            if AppStreamGlib.utils_vercmp(module.version, current_version) >= 0:
                continue
            updates.append(ModuleUpdateInfo(module.name, module.version, current_version))
    return updates


Issue = namedtuple('Issue', ['title', 'description', 'type', 'reported'])


def report_to_gitlab(config, issue: Issue) -> bool:
    if gitlab is None:
        print('gitlab module is not installed!')
        return False

    token = config.get('token')
    if not token:
        print('gitlab token required!')
        return False

    gl = gitlab.Gitlab(config['url'], private_token=token)
    project = gl.projects.get(config['repo'])
    gl_issue = project.issues.create({
        'title': issue.title,
        'description': issue.description,
        'confidential': config.get('confidential', True),
        'labels': config.get('labels', []),
    })
    print('Reported: ', gl_issue.web_url)
    return True


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--id', action='store')
    parser.add_argument('--config', action='store')
    parser.add_argument('--no-report', action='store_true')
    parser.add_argument('--no-release-check', action='store_true')
    args = parser.parse_args()

    if not args.id and not args.config:
        sys.exit('Please specify --id or --config')

    if args.config:
        try:
            with open('report-history.json', 'r') as f:
                report_history = json.load(f)
        except FileNotFoundError:
            report_history = {}
        config = json.load(open(args.config))

        if config.get('auto-update-cves', False):
            subprocess.run(['cve-check-update'], check=True)

        update_flatpaks = config.get('auto-update-flatpaks', False)

        for package in config['packages']:
            if package.get('disabled', False):
                continue

            flatpak_id = package['flatpak-name']
            remote = config['repos'][package['flatpak-repo']]
            remote['name'] = package['flatpak-repo']
            modules = get_modules_for_id(flatpak_id, remote, update_flatpaks)
            issues = []
            reported = report_history.setdefault(flatpak_id, {'cves': [], 'updates': []})

            if not modules:
                print('No modules found for', flatpak_id)
                continue

            if not args.no_release_check and 'release-monitoring-distro' in package:
                module_updates = get_module_updates(modules, package['release-monitoring-distro'], reported['updates'])
                markdown = get_updates_markdown_for_modules(module_updates)

                if not module_updates:
                    print('No new updates found for {}'.format(flatpak_id))
                elif args.no_report:
                    print(markdown)
                else:
                    new_updates = ['{}-{}'.format(module.name, module.upstream_version) for module in module_updates]
                    issues.append(Issue('New updates', markdown, 'updates', new_updates))

            cve_modules = get_modules_from_csv(get_output_for_modules(modules, True), reported['cves'])
            cve_markdown = get_cve_markdown_for_modules(cve_modules)
            if not cve_modules:
                print('No new CVEs found for {}'.format(flatpak_id))
            elif args.no_report:
                print(cve_markdown)
            else:
                new_cves = []
                for module in cve_modules:
                    new_cves += module.cves.split(' ')
                issues.append(Issue('New CVE(s) found!', cve_markdown, 'cves', new_cves))

            service = config['services'][package['service']]
            if service['type'] == 'gitlab':
                service['repo'] = package['service-repo']
                for issue in issues:
                    if report_to_gitlab(service, issue):
                        report_history[flatpak_id][issue.type] = issue.reported
                with open('report-history.json', 'w') as f:
                    json.dump(report_history, f, indent=2)
            else:
                print('Service {} not supported'.format(package['service']))
    else:
        modules = get_modules_for_id(args.id, None, False)
        if not modules:
            print('No modules found for', flatpak_id)
            sys.exit(1)

        ret = get_output_for_modules(modules, False)
        if not ret:
            print('No CVEs found!')
        else:
            print(ret)
